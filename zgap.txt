= Using ZeroMQ through the zgap script

The {|zgap|} script provides facilities to start a number of child
processes controlled by a single master process and to allow for
easy coordination between them.

== Running zgap

From the shell, run zgap via:

| bin/zgap -N <nodes> <gap_options> <gap_files>

Here, {|<nodes>|} should be a positive integer that describes the number
of workers one wishes to start. The rest of the command line, consisting
of gap options and gap files, will be passed to the master and the
worker processes verbatim. This allows, for example, the initialization
of functions that need to be known by all workers.

The first line of output will be prefixed with {|[zgap]|} and will
list the directory where {|zgap|} will store the files and sockets it
uses to communicate. In particular, the {|logXX.txt|} files will contain
the output generated by the workers; this is useful for debugging, as
the workers do not have a working break loop.

Example:

| bin/zgap -N 4 -P 8 -m 1G common.g

On NUMA architectures that support the {|numactl|} command, it is
possible to further specify which node each worker should be running on.
This can take one of two forms:

| bin/zgap -N <count>:<start>-<end>
| bin/zgap -N <count>:+<start>-<end>

Each will distribute {|<count>|} worker processes on the physical nodes
ranging from {|<start>|} to {|<end>|} in a round-robin fashion, reusing
nodes if there are more workers than nodes. The first mode (without a
{|+|} sign) will use absolute node numbers, the second will be relative
to the master process. See the {|numactl|} manual page for further
details.

Example:

| bin/zgap -N 4:+0-3 -P 8 -m 1G common.g


Note: Currently, {|zgap|} can only be run from the GAP root directory.
This is an implementation restriction that is to be removed at a later
date.

== Zgap API

The following API functions can generally communicate with one or more
nodes. Nodes can be denoted by either an integer, a range of integers,
or a list of integers. The master node corresponds to the value 0,
worker nodes are numbered starting at 1. The variable {|ZAll|} contains
a range of the worker nodes; {|ZSelf|} contains the index of the current
worker or 0 for the master.

===| ZExec(nodes, cmd)

This function sends {-cmd-} to the given node or nodes and executes
them there. The command must be a valid GAP statement ending in a
semicolon.

===| ZBind(nodes, var, expr)

This function binds the global variable described by the string {-var-}
to the value {-expr-} on all nodes listed in {-nodes-}. Note that
{-expr-} must evaluate to a serializable value.

| gap> ZBind(ZAll, "counter", 0);

===| ZUnbind(nodes, var)

This function is the counterpart to {|ZBind|}. It will unbind {-var-}
on all specified nodes.

| gap> ZUnbind(ZAll, "status");

===| ZCall(nodes, func, args)

This function will execute the function specified by the string {-func-}
on the specified nodes. The string {-func-} must be the name of a global
variable referring to the function to be executed. This function should
be created at startup by adding a file to the commandline that defines
it in all workers or by {|ZExec|}.

| gap> ZBind(ZAll, "counter", 0);
| gap> ZExec(Zall, "add := function(n) counter := counter + n; end;");
| gap> ZCall(1, "add", [1]);

===| ZQuery(nodes, func, args, callback)

This function works like {|ZCall|}, except that any return value will
be passed to the callback function.

| gap> res := false;
| false
| gap> ZQuery(1, "ReturnTrue", [], function(x) res := x; end);
| gap> res;
| true

===| ZResponse()

{|ZResponse|} is a convenience function to construct blocking callbacks
for {|ZCall|} and {|ZTask|}. It returns a record containing a {|put|},
a {|get|}, and a {|test|} function. Here, {|put|} is passed as the
callback; {|get|} can be used to read the returned value; and {|test|}
can be used to test for the presence of a value.

| gap> resp := ZResponse();;
| gap> ZQuery(1, "Z", [4], resp.put);
| gap> resp.get();
| Z(2^2)
| gap> resp.test();
| true


===| ZTask(nodes, func, args, callback)

This function works like {|ZQuery|}, except that the function will be
executed via a task and {-callback-} will be called after the task
finishes and returns a result.

===| ZAsync(nodes, func, args)

This function works like {|ZCall|}, except that the function will be
executed via a task.

===| ZRead(nodes, file)

This function does a {|Read(file)|} on all specified nodes.

===| ZReadGapRoot(nodes, file)

This function does a {|ReadGapRoot(file)|} on all specified nodes.

